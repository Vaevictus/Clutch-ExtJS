// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
Resolvers are used internally by Deferreds and Promises to capture and notify
callbacks, process callback return values and propagate resolution or rejection
to chained Resolvers.

Developers never directly interact with a Resolver.

A Resolver captures a pair of optional onResolved and onRejected callbacks and 
has an associated Promise. That Promise delegates its then() calls to the 
Resolver's then() method, which creates a new Resolver and schedules its 
delayed addition as a chained Resolver.

Each Deferred has an associated Resolver. A Deferred delegates resolve() and 
reject() calls to that Resolver's resolve() and reject() methods. The Resolver 
processes the resolution value and rejection reason, and propagates the 
processed resolution value or rejection reason to any chained Resolvers it may 
have created in response to then() calls. Once a chained Resolver has been 
notified, it is cleared out of the set of chained Resolvers and will not be 
notified again.
@private
*/

Ext.define('Deft.promise.Resolver', {
  alternateClassName: ['Deft.Resolver'],
  requires: ['Deft.util.Function'],
  constructor: function(onResolved, onRejected, onProgress) {
    var complete, completeRejected, completeResolved, completed, completionAction, completionValue, nextTick, pendingResolvers, process, processed, propagate, schedule;
    this.promise = Ext.create('Deft.promise.Promise', this);
    pendingResolvers = [];
    processed = false;
    completed = false;
    completionAction = null;
    completionValue = null;
    if (!Ext.isFunction(onRejected)) {
      onRejected = function(error) {
        throw error;
      };
    }
    nextTick = Deft.util.Function.nextTick;
    propagate = function() {
      var pendingResolver, _i, _len;
      for (_i = 0, _len = pendingResolvers.length; _i < _len; _i++) {
        pendingResolver = pendingResolvers[_i];
        pendingResolver[completionAction](completionValue);
      }
      pendingResolvers = [];
    };
    schedule = function(pendingResolver) {
      pendingResolvers.push(pendingResolver);
      if (completed) {
        propagate();
      }
    };
    complete = function(action, value) {
      onResolved = onRejected = onProgress = null;
      completionAction = action;
      completionValue = value;
      completed = true;
      propagate();
    };
    completeResolved = function(value) {
      complete('resolve', value);
    };
    completeRejected = function(reason) {
      complete('reject', reason);
    };
    process = function(callback, value) {
      var error;
      processed = true;
      try {
        if (Ext.isFunction(callback)) {
          value = callback(value);
        }
        if (value && Ext.isFunction(value.then)) {
          value.then(completeResolved, completeRejected);
        } else {
          completeResolved(value);
        }
      } catch (_error) {
        error = _error;
        completeRejected(error);
      }
    };
    this.resolve = function(value) {
      if (!processed) {
        process(onResolved, value);
      }
    };
    this.reject = function(reason) {
      if (!processed) {
        process(onRejected, reason);
      }
    };
    this.update = function(progress) {
      var pendingResolver, _i, _len;
      if (!completed) {
        if (Ext.isFunction(onProgress)) {
          progress = onProgress(progress);
        }
        for (_i = 0, _len = pendingResolvers.length; _i < _len; _i++) {
          pendingResolver = pendingResolvers[_i];
          pendingResolver.update(progress);
        }
      }
    };
    this.then = function(onResolved, onRejected, onProgress) {
      var pendingResolver;
      if (Ext.isFunction(onResolved) || Ext.isFunction(onRejected) || Ext.isFunction(onProgress)) {
        pendingResolver = Ext.create('Deft.promise.Resolver', onResolved, onRejected, onProgress);
        nextTick(function() {
          return schedule(pendingResolver);
        });
        return pendingResolver.promise;
      }
      return this.promise;
    };
    return this;
  },
  /**
  	* Resolves this Resolver with the specified value, triggering it to execute the 'onResolved' callback and propagate the resulting resolution value or rejection reason to Resolvers that originate from this Resolver.
  	*
  	* @param {Mixed} value The resolved future value.
  */

  resolve: Ext.emptyFn,
  /**
  	* Rejects this Resolver with the specified reason, triggering it to execute the 'onRejected' callback and propagate the resulting resolution value or rejection reason to Resolvers that originate from this Resolver.
  	*
  	* @param {Error} reason The rejection reason.
  */

  reject: Ext.emptyFn,
  /**
  	* Updates progress for this Resolver, if it is still pending, triggering it to execute the 'onProgress' callback and propagate the resulting transformed progress value to Resolvers that originate from this Resolver.
  	*
  	* @param {Mixed} progress The progress value.
  */

  update: Ext.emptyFn,
  /**
  	* Schedules creation of a new Resolver that originates from this Resolver, configured with the specified callbacks.  Those callbacks can subsequently transform the value that was resolved or the reason that was rejected.
  	*
  	* Each call to then() returns a new Promise of that transformed value; i.e., a Promise that is resolved with the callback return value or rejected with any error thrown by the callback.
  	*
  	* @param {Function} onFulfilled Callback function to be called when resolved.
  	* @param {Function} onRejected Callback function to be called when rejected.
  	* @param {Function} onProgress Callback function to be called with progress updates.
  	* @param {Object} scope Optional scope for the callback(s).
  	* @return {Deft.promise.Promise} A Promise of the transformed future value.
  */

  then: Ext.emptyFn
});
